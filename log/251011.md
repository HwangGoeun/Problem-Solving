# 30 Days of JavaScript - Function Transformations

어제 못 풀었던 Function Transformations 나머지 문제들을 풀어보았습니다.

<br>

---
<br>

# 2703. Return Length of Arguments Passed

전달된 인수의 길이를 반환하는 문제입니다.

<br>

```js
var argumentsLength = function(...args) {
  return arguments.length;
};
```

`arguments` 객체를 이용하여 풀었습니다.

`arguments` 객체는 함수가 호출 될 때 전달된 인자들을 저장해 놓는 유사 배열 객체입니다.

함수에 파라미터를 지정해놓지 않아도 함수 호출 시 인수를 전달했다면 `arguments` 객체에는 전달된 인수가 저장됩니다.

<br>

전달된 인수의 길이를 반환하라는 문장을 읽자마자 바로 `arguments` 객체를 이용해 풀어야겠다는 생각을 했습니다만... 다른 답변들을 보고나서 그냥 `args.length`로 풀어도 된다는 사실을 알게 되었습니다.

문제에서 입력값을 `args = [{}, null, "3"]`와 같은 형태로 지정해놓은 것을 보면, `args`를 이용하는 것이 출제자가 원했던 건가 싶기도 합니다.

<br>

---
<br>

# 2666. Allow Onc Function Call

함수 `fn`을 인수로 받아 새로운 함수를 반환하는 함수를 작성하는 문제입니다.

반환되는 함수에서는 콜백 함수 `fn`이 최초 한 번만 실행된 뒤 그 결과값을 반환하고, 그 이후부터는 `undefined`가 반환되어야 합니다.

문제 내에 있는 Example에서

```
Explanation:
const onceFn = once(fn);
onceFn(5, 7, 4); // 140
onceFn(2, 3, 6); // undefined, fn was not called
onceFn(4, 6, 8); // undefined, fn was not called
```

와 같은 형태로 변수에 함수를 할당하고, 그 변수를 이용해 함수를 계속 호출하는 방식이었기 때문에 클로저를 이용할 수 있었습니다.

<br>

```js
var once = function(fn) {
  let i = 0;
  
  return function(...args){
    if (i !== 0)    return undefined;

    i++;
    return fn(...args);     
  }
};
```

클로저 개념을 이용해 `i` 값을 비교하여 문제를 풀었습니다.

지금 보니 숫자형 변수를 이용하는 것이 아니라 `boolean` 타입 변수를 이용하는 것이 훨씬 가독성도 좋고 구현도 편했을 것 같습니다.

<br>

### 다른 코드와 비교하기

``` js
var once = function(fn) {
  let isOnce = true

  return function(...args){
    if(isOnce) {
      isOnce = false;

      return fn(...args);
    }
  }
};
```

제출된 다른 코드 중 `return` 값을 지정하지 않으면 `undefined`를 반환해주는 것을 활용한 코드가 있었습니다.

제 코드와 로직 자체는 유사합니다만, `return`을 한 번만 사용할 생각은 못해서 흥미로웠습니다!

<br>

---
<br>

# 2623. Memoize

함수 `fn`을 인수로 받아 메모이제이션 기능이 추가된 함수를 반환하는 문제입니다.

메모이제이션(Memoization)은 함수의 실행 결과를 기억해 놓은 뒤, 추후 같은 인수로 함수를 호출하는 상황이 생긴다면 함수 호출 없이 이전에 기억해놓은 실행 결과값을 반환하는 기법입니다.

<br>

메모이제이션 구현 자체는 그렇게 어렵지 않았으나... 문제 이해를 하는 데에 꽤나 애를 먹었습니다. (리트코드 단골 댓글 소재지요. 문제 이해가 가장 어렵다는...^^)

Input으로 문자열, 배열 등등...이 주어진다고 쓰여 있는데요, 그냥 **함수 하나랑 그 함수에 사용할 인수 하나씩 들어간다고 생각하고** 문제를 푸시면 되겠습니다.

<br>

``` js
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const keyName = JSON.stringify(args);

    if (!(keyName in cache)) {
      cache[keyName] = fn(...args);
    };
    
    return cache[keyName];
  }
}
```

`cache` 객체를 만들어 메모이제이션에 사용했습니다.

전달된 인수를 문자열로 변환한 뒤, `cache` 객체의 키로 사용하여 이전에 동일한 인수로 함수가 실행되었는지 여부를 확인했습니다.

<br>

### 풀이 과정 중 발생한 문제 1

동일한 키값이 있는지 확인하는 `if (!(keyName in cache))` 구문에서 오류가 있었습니다.

이전에는 조건식을 `if (!cache[keyName])`으로 작성하여 `keyName`이 없다면 `undefined`를 반환할 것이라 예상했습니다.

하지만 이전 조건식에서는 `cache[keyName]`의 value를 반환하기 때문에, `[0, 0]`과 같은 형태의 인수가 들어오게 된다면 조건식의 결과값 자체가 true가 되어버려 다시 함수를 호출할 수 있게 됩니다.

객체에 원하는 key가 있는지 확인하기 위해서는 [`in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in) 연산자를 사용해야 합니다.

<br>

### 풀이 과정 중 발생한 문제 2

만약 key가 없다면 콜백 함수를 호출하는 `cache[keyName] = fn(...args);` 코드에서, 함수 `fn`의 인수로 `args`를 주었습니다.

[나머지 매개변수](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)를 사용하지 않고 그대로 넘기게 되면, 인수는 배열 형태로 전달되게 됩니다.

따라서, 함수가 요구했던 인수의 조건을 충족하기 위해서는 나머지 매개변수를 사용해 배열의 요소를 인수 형태로 만들어 전달해야 합니다.
