# 30 Days of JavaScript - Function Transformations (Function Composition)

중첩 함수를 구현하는 문제입니다.

<br>

---
<br>

## 2629. Function Composition

``` js
var compose = function(functions) {
	return function (x) {
		if (functions.length === 0) return x;
		
		if (functions.length === 1) return functions[0](x);
		
		return functions[0]( compose( functions.slice(1) )(x) );
	}
};
```

함수 배열이 주어졌을 때, 배열 저장된 순서대로 바깥에서 안으로 함수를 중첩하여 중첩 함수를 만듭니다.

이후 새로운 만든 중첩 함수에 인자를 전달했을 때, 실행 결과값을 반환하는 문제입니다.

<br>

워터폴을 구현했을 때와 비슷하다는 느낌을 받았습니다.

워터폴을 구현할 당시에도 결과값을 전달하는 과정에서 굉장히 애를 먹었는데, 이번에도 문제를 상당히 어렵게 푼 것 같습니다.

문제를 풀고서도 '배열을 다시 인자로 보내진 않을 것 같은데?' 하는 생각이 들었습니다.

<br>

### 오류 점검하기

처음에는 `compose()` 함수 선언부와 익명 함수 선언부 사이에 변수 `i`를 선언하고,

함수가 반복될 때마다 `i` 값을 1씩 추가하여 `i`의 값이 함수 배열의 길이와 동일해질 때 함수를 실행 결과를 반환하고자 했는데요,

음... 문제 풀이 접근부터 잘못했던 것 같습니다.

``` js
// 처음에 작성했던 코드

var compose = function(functions) {
	
	let i = 0

	return function (x) {
		if (i === functions.length - 1) return x;
		
		return functions[i]( functions[++i](x) );
	}
};
```

1. 일단 익명함수의 반환값에서, 콜백함수가 재귀로 실행되지 않았습니다. 만약 재귀로 실행하고 싶었다면 콜백함수로 `compose()`를 사용했어야 합니다.
2. 콜백함수로 `compose()`를 집어넣는 경우에도 `i`는 매번 새롭게 선언되기 때문에, 결국 항상 0의 값을 유지하게 됩니다. (이 부분은 클로저를 정확히 이해하지 못해 문제 풀이 방법을 잘못 접근한 것 같습니다.)

<br>

결국 `compose()`를 재귀로 실행하여 문제를 풀긴 했습니다만, 풀고 나서도 '이건 아니다' 하는 확신이 강하게 들었습니다.

배열을 인자로 받아서 맨 앞의 요소를 제거한 배열을 또 인자로 보낸다니요?

일단 재귀함수를 사용했기 때문에, 배열의 길이가 길어지면 길어질 수록 콜스택의 부담은 상당할 겁니다.

그리고 인자로 전달된 함수 배열의 요소 중 사용해야 하는 요소는 단 두 개인데, 나머지 요소까지 인자로 보내는 것 자체가 컴퓨터 자원을 크게 낭비하는 것이죠.

<br>

### 다른 코드와 비교하기

``` js
var compose = function(functions) {
		
	return function(x) {
		for (const func of functions.reverse()) {
				x = func(x);
		}
		
		return x;
	}
};
```

다른 제출된 코드를 확인해 보았습니다. 위 코드는 제출된 코드 중 가장 마음에 들었던 코드입니다.

중첩 함수를 만들 때에는 인자로 전달된 배열의 첫 번째 요소가 가장 바깥에, 마지막 요소는 가장 안 쪽에 있어야 한다는 조건을 충족하기 위해 `reverse()` 메소드를 사용하여 `functions` 배열을 역순으로 바꿔주었습니다.

이후 `functions` 배열에 있는 함수들을 하나씩 호출하며 실행 결과값을 `x`에 할당합니다.

이전 실행의 결과값을 다음 실행에서 그대로 사용하기 때문에, `x` 값은 최종적으로 중첩함수의 실행 결과가 나오게 됩니다.

빈 배열이 전달되는 경우에도 `x`의 값을 그대로 반환하기 때문에, 별도로 `if` 조건문을 만들 필요가 없습니다. (굿!)

<br>

저는 효율적인 코드를 보면 아름답다는 표현을 하는데요, 정말 예쁘고 아름다운 코드라고 생각합니다. 

`for...of`문 하나만으로 공백 배열, 요소가 있는 배열 모두 처리할 수 있기 때문입니다.

크으... 오늘도 배우고 갑니다.

(근데 [`reduce()`를 구현할 때](../LeetCode/JavaScript/2626.js) 같은 방법을 사용했는데 왜 지금은 생각하지 못했던 걸까요? 코드의 로직을 이해한 것이 아니라 코드 자체를 외웠기 때문이 아닐까... 하는 반성을 해봅니다.)
